# InvertedIndex #
&emsp;&emsp;基于实验要求，可以实现一个根据输入的单词或字母字符串实现文件检索功能的程序，原理就是倒排索引。考虑到实验3已经实现了简单的倒排索引，因此在原有倒排索引输出的value的信息上增加了单词位置的列表。为了搜索结果的精确性，将检索关键词和所有关键词都转成小写后再进行匹配。检索关键词是读取一整行，过滤掉非文本字符(大写、小写、'-'以外的字符)，将其作为分界符，只要匹配上所有子串，就认为该单词匹配此关键词。例如 **检索输入ex_p，结果就是包含ex和p的单词**。程序运行方式与实验3一致，区别就是输入hadoop命令后需要输入检索关键词才能继续运行。  
&emsp;&emsp;倒排索引结果的key-value对为 **单词-单词信息列表** ，也就是程序最终的输出结果。  
&emsp;&emsp;单词信息列表的单一项形式为 **“(文件名:单词个数 单词位置列表);\n”** 。该列表先按照单词个数降序排序，如果单词个数相同，则按照文件名词典序排序。这样排序是比较符合实际的。匹配单词数量多相当于相关度高，自然也就应该优先显示。合并此列表项以及该列表项排序由 **InvertedIndexReducer** 通过ArrayList实现。  
&emsp;&emsp;单词位置由 **[行号 所在行第几个单词]** 表示，例如搜索的是day，文本为"An apple a day",该单词对应的位置信息为[1 4]。有时候第一个数字表示段落，对应正常文本文件的情况，因为实验所用的是hadoop的配置文件，所以为行号。单词位置按照括号里的行号升序排序，如果相同，第二个数字即为排序的参考。单词位置列表由 **InvertedIndexCombiner** 通过ArrayList实现。  
&emsp;&emsp; **InvertedIndexMapper** 就是处理文本，以每一行作为value，将value用正则表达式替换所有与文本无关的符号，分割单词，然后所有单词与检索关键词匹配，匹配成功则生成形如 **(word:filename,1 [linenum position])** 的(key,value)对。不成功则直接跳过不处理。  
